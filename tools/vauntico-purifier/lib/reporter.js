const fs = require('fs').promises;
const path = require('path');
const chalk = require('chalk');
const { scanner } = require('./scanner');

/**
 * VAUNTICO REPORTER
 * Generates mystical corruption maps and analysis reports
 */

class VaunticoReporter {
  constructor() {
    this.severityColors = {
      critical: chalk.red.bold,
      high: chalk.red,
      medium: chalk.yellow,
      low: chalk.blue
    };
    
    this.severityEmoji = {
      critical: 'ðŸ”¥',
      high: 'âš ï¸',
      medium: 'ðŸ’¡',
      low: 'â„¹ï¸'
    };
  }

  async generate(targetPath, options = {}) {
    const { format = 'console', output = './corruption-report.json' } = options;
    
    console.log(chalk.blue(`ðŸ“Š Analyzing: ${targetPath}`));
    
    // Use scanner to get corruption data
    const scanResults = await scanner.scan(targetPath, { verbose: false });
    
    const report = {
      timestamp: new Date().toISOString(),
      targetPath: path.resolve(targetPath),
      summary: scanResults.summary,
      totalFiles: scanResults.totalFiles,
      totalCorruptions: scanResults.corruptions.length,
      corruptions: scanResults.corruptions,
      metadata: {
        tool: '@vauntico/purifier',
        version: '1.0.0',
        doctrine: 'From corruption comes clarity. From chaos comes code.'
      }
    };
    
    switch (format) {
      case 'json':
        await this._generateJSON(report, output);
        break;
      case 'markdown':
        return await this._generateMarkdown(report, output);
      case 'console':
      default:
        return { formatted: this._generateConsole(report) };
    }
    
    return report;
  }

  async _generateJSON(report, outputPath) {
    const jsonContent = JSON.stringify(report, null, 2);
    await fs.writeFile(outputPath, jsonContent, 'utf8');
    console.log(chalk.green(`âœ… JSON report saved: ${outputPath}`));
  }

  async _generateMarkdown(report, outputPath) {
    const markdown = this._buildMarkdownReport(report);
    await fs.writeFile(outputPath, markdown, 'utf8');
    console.log(chalk.green(`âœ… Markdown report saved: ${outputPath}`));
    return { formatted: markdown };
  }

  _generateConsole(report) {
    const lines = [];
    
    // Header
    lines.push(chalk.yellow('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
    lines.push(chalk.yellow('â•‘') + '                  ' + chalk.bold.white('CORRUPTION REPORT') + '                  ' + chalk.yellow('â•‘'));
    lines.push(chalk.yellow('â•‘') + '              ' + chalk.italic.gray('Generated by Vauntico Purifier') + '            ' + chalk.yellow('â•‘'));
    lines.push(chalk.yellow('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
    lines.push('');
    
    // Summary
    lines.push(chalk.bold.white('ðŸ“Š ANALYSIS SUMMARY'));
    lines.push('');
    lines.push(`${chalk.cyan('Target Path:')} ${report.targetPath}`);
    lines.push(`${chalk.cyan('Scanned Files:')} ${report.totalFiles}`);
    lines.push(`${chalk.cyan('Total Corruptions:')} ${report.totalCorruptions}`);
    lines.push(`${chalk.cyan('Timestamp:')} ${new Date(report.timestamp).toLocaleString()}`);
    lines.push('');
    
    // Severity Breakdown
    if (report.totalCorruptions > 0) {
      lines.push(chalk.bold.white('ðŸš¨ CORRUPTION BREAKDOWN'));
      lines.push('');
      
      Object.entries(report.summary).forEach(([severity, count]) => {
        if (count > 0) {
          const color = this.severityColors[severity];
          const emoji = this.severityEmoji[severity];
          lines.push(`  ${emoji} ${color(severity.toUpperCase())}: ${count}`);
        }
      });
      lines.push('');
      
      // Detailed Corruptions
      lines.push(chalk.bold.white('ðŸ“‹ DETAILED FINDINGS'));
      lines.push('');
      
      const groupedCorruptions = this._groupCorruptionsByFile(report.corruptions);
      
      Object.entries(groupedCorruptions).forEach(([file, corruptions]) => {
        lines.push(chalk.bold.cyan(`ðŸ“„ ${file}`));
        
        corruptions.forEach((corruption, index) => {
          const color = this.severityColors[corruption.severity];
          const emoji = this.severityEmoji[corruption.severity];
          const lineInfo = corruption.line ? `:${corruption.line}` : '';
          
          lines.push(`   ${emoji} ${color(corruption.type)}${lineInfo}`);
          if (corruption.details) {
            lines.push(chalk.gray(`      ${corruption.details}`));
          }
        });
        lines.push('');
      });
    } else {
      lines.push(chalk.bold.green('ðŸŽ‰ NO CORRUPTIONS DETECTED'));
      lines.push('');
      lines.push(chalk.cyan('Your JSX is pure and blessed by the ancients.'));
    }
    
    // Footer
    lines.push(chalk.gray('â”€'.repeat(60)));
    lines.push(chalk.italic.gray('"From corruption comes clarity. From chaos comes code."'));
    lines.push(chalk.gray(`Generated by ${report.metadata.tool} v${report.metadata.version}`));
    
    return lines.join('\n');
  }

  _buildMarkdownReport(report) {
    const lines = [];
    
    // Header
    lines.push('# ðŸ”¥ Vauntico Purifier - Corruption Report');
    lines.push('');
    lines.push('> *"From corruption comes clarity. From chaos comes code."*');
    lines.push('');
    
    // Metadata
    lines.push('## ðŸ“Š Analysis Summary');
    lines.push('');
    lines.push(`- **Target Path:** \`${report.targetPath}\``);
    lines.push(`- **Files Scanned:** ${report.totalFiles}`);
    lines.push(`- **Total Corruptions:** ${report.totalCorruptions}`);
    lines.push(`- **Generated:** ${new Date(report.timestamp).toLocaleString()}`);
    lines.push(`- **Tool:** ${report.metadata.tool} v${report.metadata.version}`);
    lines.push('');
    
    if (report.totalCorruptions > 0) {
      // Severity Breakdown
      lines.push('## ðŸš¨ Corruption Breakdown');
      lines.push('');
      lines.push('| Severity | Count | Status |');
      lines.push('|----------|-------|--------|');
      
      Object.entries(report.summary).forEach(([severity, count]) => {
        const emoji = this.severityEmoji[severity];
        const status = count > 0 ? 'âŒ Needs Attention' : 'âœ… Clean';
        lines.push(`| ${emoji} ${severity.toUpperCase()} | ${count} | ${status} |`);
      });
      lines.push('');
      
      // Detailed Findings
      lines.push('## ðŸ“‹ Detailed Findings');
      lines.push('');
      
      const groupedCorruptions = this._groupCorruptionsByFile(report.corruptions);
      
      Object.entries(groupedCorruptions).forEach(([file, corruptions]) => {
        lines.push(`### ðŸ“„ \`${file}\``);
        lines.push('');
        
        corruptions.forEach((corruption) => {
          const emoji = this.severityEmoji[corruption.severity];
          const lineInfo = corruption.line ? ` (Line ${corruption.line})` : '';
          
          lines.push(`- ${emoji} **${corruption.type}**${lineInfo}`);
          if (corruption.details) {
            lines.push(`  - *${corruption.details}*`);
          }
        });
        lines.push('');
      });
    } else {
      lines.push('## ðŸŽ‰ Clean Codebase');
      lines.push('');
      lines.push('No corruptions detected! Your JSX is pure and blessed by the ancients.');
    }
    
    // Recommendations
    lines.push('## ðŸ”§ Recommendations');
    lines.push('');
    
    if (report.totalCorruptions > 0) {
      lines.push('Run the following command to automatically fix detected issues:');
      lines.push('');
      lines.push('```bash');
      lines.push('vauntico-purifier autofix --commit');
      lines.push('```');
      lines.push('');
      lines.push('For a complete purification ritual:');
      lines.push('');
      lines.push('```bash');
      lines.push('vauntico-purifier ritual --commit');
      lines.push('```');
    } else {
      lines.push('Your codebase is already pure. Consider running periodic scans to maintain harmony:');
      lines.push('');
      lines.push('```bash');
      lines.push('vauntico-purifier scan --verbose');
      lines.push('```');
    }
    
    return lines.join('\n');
  }

  _groupCorruptionsByFile(corruptions) {
    return corruptions.reduce((groups, corruption) => {
      const file = corruption.file;
      if (!groups[file]) {
        groups[file] = [];
      }
      groups[file].push(corruption);
      return groups;
    }, {});
  }
}

const reporter = new VaunticoReporter();

module.exports = {
  reporter
};